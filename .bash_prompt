# set up fancy colored prompt
# =============================================================================
# NOTE: these colors make no sense without Solarized color scheme installed
# get it @ http://ethanschoonover.com/solarized

# define basic color codes
# -----------------------------------------------------------------------------

# text colors
text_blue='0;34'
text_cyan='0;36'
text_faded='0;30'
text_gray='1;32'
text_green='0;32'
text_magenta='0;35'
text_normal='0'
text_orange='1;31'
text_purple='1;35'
text_red='0;31'
text_yellow='0;33'

# background colors
bg_blue='44'
bg_cyan='46'
bg_green='42'
bg_magenta='45'
bg_offwhite='47'
bg_red='41'
bg_select='40'
bg_yellow='43'

# create a combined color code for a specified text/background color pair
function color_code() {
  color_text=$1;
  color_bg=$2;
  if [ -z $color_bg ]; then
    color_bg=""
  else
    color_bg=";$color_bg"
  fi
  echo "\[\033[${color_text}${color_bg}m\]"
}
unset color_text color_bg

# define which colors to use for each part of the prompt
# -----------------------------------------------------------------------------

color_reset=$(color_code $text_normal)
color_user_host=$(color_code $text_blue)
color_working_dir=$(color_code $text_cyan)
color_prompt=$(color_code $text_magenta)
color_separator=$(color_code $text_gray)

# git_info() colors
color_git_clean=$(color_code $text_green)
color_git_staged=$(color_code $text_yellow)
color_git_unstaged=$(color_code $text_orange)

# define (colorized) text for each part of the prompt
# -----------------------------------------------------------------------------

user_host="\n${color_user_host}\u@\h${color_reset}"
working_dir="${color_working_dir}\w${color_reset}"
prompt="\n${color_prompt}\$${color_reset} "
separator="${color_separator}:${color_reset}"

# display currently checked out branch name when you're in a git repo
# color dependent upon changes status: none/staged/unstaged
function git_info() {
  git_dir=`git rev-parse --git-dir 2>/dev/null`
  if [ -z "$git_dir" ]; then
    return 0
  fi

  git_head=`cat $git_dir/HEAD`
  git_branch=${git_head##*/}
  if [ ${#git_branch} -eq 40 ]; then
    git_branch="(no branch)"
  fi

  git_status=`git status --porcelain`
  if [ -z "$git_status" ]; then
    color_git=$color_git_clean
  else
    echo -e "$git_status" | grep -q '^ [A-Z\?]'
    if [ $? -eq 0 ]; then
      color_git=$color_git_unstaged
    else
      color_git=$color_git_staged
    fi
  fi

  echo "${separator}${color_git}${git_branch}${color_reset}"
}

# define actual prompt in terms of all that other stuff defined above
# -----------------------------------------------------------------------------
# NOTE: PS1 has to be assigned as part of PROMPT_COMMAND 
# for the git_info() function to be actually re-evaluated when appropriate

PROMPT_COMMAND='PS1="${user_host}${separator}${working_dir}$(git_info)${prompt}"'
